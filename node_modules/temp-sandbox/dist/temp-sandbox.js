"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TempSandbox = void 0;

var _path = _interopRequireDefault(require("path"));

var _os = _interopRequireDefault(require("os"));

var _fs = _interopRequireDefault(require("fs"));

var _crypto = require("crypto");

var _util = require("util");

var _makeDir = _interopRequireWildcard(require("make-dir"));

var _parentModule = _interopRequireDefault(require("parent-module"));

var _readPkgUp = _interopRequireDefault(require("read-pkg-up"));

var _readDirDeep = require("read-dir-deep");

var _slash = _interopRequireDefault(require("slash"));

var _del = require("./utils/del");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const writeFile = (0, _util.promisify)(_fs.default.writeFile);
const readFile = (0, _util.promisify)(_fs.default.readFile);

function getFileHash(contents) {
  const hash = (0, _crypto.createHash)('md5').update(contents).digest('hex');
  return hash;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function createFileParseContents(contents = '') {
  let fileContents = contents;

  if (fileContents === null) {
    fileContents = '';
  }

  if (typeof fileContents !== 'string') {
    fileContents = JSON.stringify(fileContents, null, 4);
  } // all files append new line unless empty


  if (fileContents.slice(-1) !== '\n' && fileContents !== '') {
    fileContents += '\n';
  }

  return fileContents;
}

function sandboxDestroyed() {
  throw new Error('sandbox has been destroyed. Create new instance');
} // https://stackoverflow.com/a/1527820


function getRandomInteger(min = 1, max = 100) {
  const randomInteger = Math.floor(Math.random() * (max - min + 1)) + min;
  return randomInteger;
}

class TempSandbox {
  constructor(options = {}) {
    _defineProperty(this, "dir", void 0);

    _defineProperty(this, "path", {
      resolve: dir => {
        const absolute = _path.default.resolve(this.dir, dir);

        const relative = _path.default.relative(this.dir, absolute);

        const isOutside = relative !== '' ? relative.split('..')[0] === '' : false;

        if (isOutside) {
          throw new Error(`${dir} is outside sandbox`);
        } // Treat the directory as if it is the root of the filesystem


        const base = _path.default.join('/', relative);

        const joinWithBase = _path.default.join(this.dir, base);

        const normalized = (0, _slash.default)(_path.default.resolve(joinWithBase));
        return normalized;
      },
      relative: (dir1, dir2) => {
        const from = dir2 ? this.path.resolve(dir1) : this.dir;
        const to = dir2 ? this.path.resolve(dir2) : this.path.resolve(dir1);
        const relative = (0, _slash.default)(_path.default.relative(from, to));
        return relative;
      }
    });

    const opts = {
      randomDir: false,
      ...options
    };

    const tempDir = _fs.default.realpathSync(_os.default.tmpdir());

    const parent = (0, _parentModule.default)() || `PARENT-NOT-FOUND-${getRandomInteger()}`;

    const relativeParent = _path.default.relative(process.cwd(), parent);

    const relativeParentParsed = _path.default.parse(relativeParent);

    const relateParentStrippedExt = _path.default.join(relativeParentParsed.dir, relativeParentParsed.name);
    /**
     * create base directory based on package name
     */


    const packageJson = _readPkgUp.default.sync({
      cwd: parent,
      normalize: false
    });

    const baseDirId = packageJson && packageJson.package && packageJson.package.name ? packageJson.package.name // replace special characters for directory name
    .replace(/[^a-zA-Z0-9]/g, '-') : null;

    if (baseDirId === null) {
      throw new Error('package name not found');
    }

    const dirId = opts.randomDir === false ? 'dir' : getRandomInteger().toString();

    const baseDir = _path.default.resolve(tempDir, `${baseDirId}-sandbox`);
    /**
     * Each temp directory will be unique to the file
     */


    this.dir = (0, _slash.default)(_path.default.resolve(baseDir, `${relateParentStrippedExt}-${dirId}`)); // Remove target temp directory if it already exists

    if (_fs.default.existsSync(this.dir)) {
      _del.del.sync(this.dir, {
        force: true
      });
    } // create sandbox directory


    (0, _makeDir.sync)(this.dir);
    this.path.relative = this.path.relative.bind(this);
    this.path.resolve = this.path.resolve.bind(this);
    this.createDir = this.createDir.bind(this);
    this.createDirSync = this.createDirSync.bind(this);
    this.createFile = this.createFile.bind(this);
    this.createFileSync = this.createFileSync.bind(this);
    this.delete = this.delete.bind(this);
    this.deleteSync = this.deleteSync.bind(this);
    this.readFile = this.readFile.bind(this);
    this.readFileSync = this.readFileSync.bind(this);
    this.getFileHash = this.getFileHash.bind(this);
    this.getFileHashSync = this.getFileHashSync.bind(this);
    this.getFileList = this.getFileList.bind(this);
    this.getFileListSync = this.getFileListSync.bind(this);
    this.getAllFilesHash = this.getAllFilesHash.bind(this);
    this.getAllFilesHashSync = this.getAllFilesHashSync.bind(this);
    this.clean = this.clean.bind(this);
    this.cleanSync = this.cleanSync.bind(this);
    this.destroySandbox = this.destroySandbox.bind(this);
    this.destroySandboxSync = this.destroySandboxSync.bind(this);
  } // eslint-disable-next-line @typescript-eslint/member-ordering


  async createDir(dir) {
    const normalized = this.path.resolve(dir);
    const dirCreated = await (0, _makeDir.default)(normalized);
    return this.path.relative(dirCreated);
  }

  createDirSync(dir) {
    const normalized = this.path.resolve(dir);
    const dirCreated = (0, _makeDir.sync)(normalized);
    return this.path.relative(dirCreated);
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  async createFile(file, contents = '') {
    const fileDir = _path.default.parse(file).dir;

    if (fileDir) {
      await this.createDir(fileDir);
    }

    const filePath = this.path.resolve(file);
    const fileContents = createFileParseContents(contents);
    await writeFile(filePath, fileContents);
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  createFileSync(file, contents = '') {
    const fileDir = _path.default.parse(file).dir;

    if (fileDir) {
      this.createDirSync(fileDir);
    }

    const filePath = this.path.resolve(file);
    const fileContents = createFileParseContents(contents);

    _fs.default.writeFileSync(filePath, fileContents);
  }

  async delete(patterns) {
    (Array.isArray(patterns) ? patterns : [patterns]).forEach(pattern => {
      if (typeof pattern !== 'string') {
        throw new Error(`delete patterns must be a string. Received type: "${typeof pattern}"`);
      }

      const filePath = this.path.resolve(pattern);

      if (filePath === this.dir) {
        throw new Error('Use sandbox.destroySandbox() to delete the sandbox.');
      }
    });
    const removed = await (0, _del.del)(patterns, {
      cwd: this.dir,
      dot: true,
      force: true
    });
    return removed.map(removedFiles => {
      return this.path.relative(removedFiles);
    });
  }

  deleteSync(patterns) {
    (Array.isArray(patterns) ? patterns : [patterns]).forEach(pattern => {
      if (typeof pattern !== 'string') {
        throw new Error(`delete patterns must be a string. Received type: "${typeof pattern}"`);
      }

      const filePath = this.path.resolve(pattern);

      if (filePath === this.dir) {
        throw new Error('Use sandbox.destroySandboxSync() to delete the sandbox.');
      }
    });

    const removed = _del.del.sync(patterns, {
      cwd: this.dir,
      dot: true,
      force: true
    });

    return removed.map(removedFiles => {
      return this.path.relative(removedFiles);
    });
  }

  async readFile(file) {
    const filePath = this.path.resolve(file);
    let contents = await readFile(filePath, 'utf8');

    try {
      contents = contents.trim();
      contents = JSON.parse(contents); // eslint-disable-next-line no-empty
    } catch (e) {}

    return contents;
  }

  readFileSync(file) {
    const filePath = this.path.resolve(file);

    let contents = _fs.default.readFileSync(filePath, 'utf8');

    try {
      contents = contents.trim();
      contents = JSON.parse(contents); // eslint-disable-next-line no-empty
    } catch (e) {}

    return contents;
  }

  async getFileHash(file) {
    const filePath = this.path.resolve(file);
    const contents = await readFile(filePath);
    const fileHash = getFileHash(contents);
    return fileHash;
  }

  getFileHashSync(file) {
    const filePath = this.path.resolve(file);

    const contents = _fs.default.readFileSync(filePath);

    const fileHash = getFileHash(contents);
    return fileHash;
  }

  async getFileList(dir) {
    const readDir = dir ? this.path.resolve(dir) : this.dir;
    const fileList = await (0, _readDirDeep.readDirDeep)(readDir, {
      cwd: this.dir,
      absolute: false,
      ignore: [],
      gitignore: false
    });
    return fileList;
  }

  getFileListSync(dir) {
    const readDir = dir ? this.path.resolve(dir) : this.dir;
    const fileList = (0, _readDirDeep.readDirDeepSync)(readDir, {
      cwd: this.dir,
      absolute: false,
      ignore: [],
      gitignore: false
    });
    return fileList;
  }

  async getAllFilesHash(dir) {
    const fileList = await this.getFileList(dir);
    const result = {};
    const pending = fileList.map(async file => {
      const hash = await this.getFileHash(file);
      result[file] = hash;
    });
    await Promise.all(pending);
    const sortedResult = Object.keys(result).sort((a, b) => {
      return a.localeCompare(b);
    }).reduce((acc, item) => {
      return { ...acc,
        [item]: result[item]
      };
    }, {});
    return sortedResult;
  }

  getAllFilesHashSync(dir) {
    const fileList = this.getFileListSync(dir);
    const result = fileList.reduce((acc, file) => {
      const fileHash = this.getFileHashSync(file);
      return { ...acc,
        [file]: fileHash
      };
    }, {});
    const sortedResult = Object.keys(result).sort((a, b) => {
      return a.localeCompare(b);
    }).reduce((acc, item) => {
      return { ...acc,
        [item]: result[item]
      };
    }, {});
    return sortedResult;
  }

  async clean() {
    const removed = await (0, _del.del)('**/*', {
      cwd: this.dir,
      dot: true,
      force: true
    });
    return removed.map(removedFiles => {
      return (0, _slash.default)(this.path.relative(removedFiles));
    });
  }

  cleanSync() {
    const removed = _del.del.sync('**/*', {
      cwd: this.dir,
      dot: true,
      force: true
    });

    return removed.map(removedFiles => {
      return (0, _slash.default)(this.path.relative(removedFiles));
    });
  }

  async destroySandbox() {
    const removed = await (0, _del.del)(this.dir, {
      force: true
    });

    for (const key of Object.keys(this)) {
      if (key === 'dir') {
        // @ts-ignore
        delete this.dir;
      } else {
        // @ts-ignore
        this[key] = sandboxDestroyed;
      }
    }

    return removed.map(file => {
      return (0, _slash.default)(file);
    });
  }

  destroySandboxSync() {
    const removed = _del.del.sync(this.dir, {
      force: true
    });

    for (const key of Object.keys(this)) {
      if (key === 'dir') {
        // @ts-ignore
        delete this.dir;
      } else {
        // @ts-ignore
        this[key] = sandboxDestroyed;
      }
    }

    return removed.map(file => {
      return (0, _slash.default)(file);
    });
  }

}

exports.TempSandbox = TempSandbox;
//# sourceMappingURL=temp-sandbox.js.map