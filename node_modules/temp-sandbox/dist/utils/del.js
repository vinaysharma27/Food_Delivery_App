"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.del = del;

var _path = _interopRequireDefault(require("path"));

var _del = _interopRequireWildcard(require("del"));

var _slash = _interopRequireDefault(require("slash"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function del(patterns, options = {}) {
  // workaround for https://github.com/sindresorhus/del/issues/68
  let removeTheseFiles = await (0, _del.default)(patterns, { ...options,
    dryRun: true
  });
  removeTheseFiles = removeTheseFiles.map(file => {
    return (0, _slash.default)(file);
  });

  try {
    const removed = await (0, _del.default)(removeTheseFiles, options);
    return removed;
  } catch (error) {
    /**
     * Intermittently error code 'EINVAL' is being thrown here.
     * Would be great to find out why
     * Test will fail only if validating removed files.
     */
    if (error.code === 'EINVAL') {
      // when the EINVAL happens, the files are usually removed 90% of the time. Run delActual again to get the remaining 10%
      await (0, _del.default)(removeTheseFiles, options); // del returns absolute files with system's path.sep

      return removeTheseFiles.map(file => {
        return _path.default.resolve(file);
      });
    }

    throw error;
  }
} // EINVAL does not happen async


del.sync = _del.sync;
//# sourceMappingURL=del.js.map